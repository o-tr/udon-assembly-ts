import type { ClassRegistry } from "./frontend/class_registry.js";
import type { UdonBehaviourLayouts } from "./ir/udon_behaviour_layout.js";

export function computeExposedLabels(
  registry: ClassRegistry,
  udonBehaviourLayouts: UdonBehaviourLayouts,
  entryClassName?: string | null,
): Set<string> {
  const exposed = new Set<string>();

  // _start is always generated by the TAC converter and must survive
  // optimization so that runtime init code (e.g. restricted-type lowering)
  // injected after _start in the assembler is reachable.
  exposed.add("_start");

  // Collect interface export method names for each UdonBehaviour interface
  const interfaceExportNames = new Set<string>();
  for (const iface of registry.getAllInterfaces()) {
    const ifaceLayout = udonBehaviourLayouts.get(iface.name);
    if (!ifaceLayout) continue;
    for (const ml of ifaceLayout.values()) {
      interfaceExportNames.add(ml.exportMethodName);
    }
  }

  for (const cls of registry.getAllClasses()) {
    const layout = udonBehaviourLayouts.get(cls.name);
    if (!layout) continue;

    for (const method of cls.methods) {
      const ml = layout.get(method.name);
      if (!ml) continue;
      const isEntryPublic = cls.name === entryClassName && method.isPublic;
      // A method is an interface method if its export name matches an interface layout entry
      const isInterfaceMethod = interfaceExportNames.has(ml.exportMethodName);
      if (!method.isExported && !isEntryPublic && !isInterfaceMethod) continue;
      exposed.add(ml.exportMethodName);
    }
  }
  return exposed;
}

export function computeExportLabels(
  registry: ClassRegistry,
  udonBehaviourLayouts: UdonBehaviourLayouts,
  entryClassName?: string | null,
): Set<string> {
  return computeExposedLabels(registry, udonBehaviourLayouts, entryClassName);
}
